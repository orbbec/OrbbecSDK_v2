// Generated by gencpp from file sensor_msgs/LiDARFrame.msg
// DO NOT EDIT!

#ifndef SENSOR_MSGS_MESSAGE_LIDAR_FRAME_H
#define SENSOR_MSGS_MESSAGE_LIDAR_FRAME_H

#include <memory>
#include <string>
#include <vector>
#include <map>
#include <limits>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace sensor_msgs {

namespace lidar_formats {
const std::string Point3D       = "point3d";
const std::string SpherePoint3D = "spherepoint3d";
const std::string Scan          = "scan";
const std::string Calibration   = "calibration";
}  // namespace lidar_formats

template <class ContainerAllocator> struct LiDARFrame_ {
    typedef LiDARFrame_<ContainerAllocator> Type;

    LiDARFrame_()
        : header(),
          data(),
          format(),
          number(0),
          timestamp_usec(0),
          timestamp_systemusec(0),
          timestamp_globalusec(0),
          metadatasize(0) {}
    LiDARFrame_(const ContainerAllocator &_alloc)
        : header(_alloc),
          data(_alloc),
          format(_alloc),
          number(0),
          timestamp_usec(0),
          timestamp_systemusec(0),
          timestamp_globalusec(0),
          metadatasize(0) {
        (void)_alloc;
    }

    typedef ::std_msgs::Header_<ContainerAllocator> _header_type;
    _header_type                                    header;

    typedef std::vector<uint8_t, typename ContainerAllocator::template rebind<uint8_t>::other> _data_type;
    _data_type                                                                                 data;

    typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other> _format_type;
    _format_type     format;

    typedef uint64_t _number_type;
    _number_type     number;

    typedef uint64_t _timestamp_type;
    _timestamp_type  timestamp_usec;

    typedef uint64_t      _timestamp_systemusec;
    _timestamp_systemusec timestamp_systemusec;

    typedef uint64_t      _timestamp_globalusec;
    _timestamp_globalusec timestamp_globalusec;

    typedef uint32_t   _metadatasize_type;
    _metadatasize_type metadatasize;

    typedef std::shared_ptr<::sensor_msgs::LiDARFrame_<ContainerAllocator>>       Ptr;
    typedef std::shared_ptr<::sensor_msgs::LiDARFrame_<ContainerAllocator> const> ConstPtr;

};  // struct LiDARFrame_

typedef ::sensor_msgs::LiDARFrame_<std::allocator<void>> LiDARFrame;

typedef std::shared_ptr<::sensor_msgs::LiDARFrame>       LiDARFramePtr;
typedef std::shared_ptr<::sensor_msgs::LiDARFrame const> LiDARFrameConstPtr;

// constants requiring out of line definition

template <typename ContainerAllocator> std::ostream &operator<<(std::ostream &s, const ::sensor_msgs::LiDARFrame_<ContainerAllocator> &v) {
    orbbecRosbag::message_operations::Printer<::sensor_msgs::LiDARFrame_<ContainerAllocator>>::stream(s, "", v);
    return s;
}

}  // namespace sensor_msgs

namespace orbbecRosbag {
namespace message_traits {

// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/kinetic/share/geometry_msgs/cmake/../msg'], 'sensor_msgs':
// ['/tmp/binarydeb/ros-kinetic-sensor-msgs-1.12.5/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__',
// '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields',
// 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']

template <class ContainerAllocator> struct IsFixedSize<::sensor_msgs::LiDARFrame_<ContainerAllocator>> : FalseType {};

template <class ContainerAllocator> struct IsFixedSize<::sensor_msgs::LiDARFrame_<ContainerAllocator> const> : FalseType {};

template <class ContainerAllocator> struct IsMessage<::sensor_msgs::LiDARFrame_<ContainerAllocator>> : TrueType {};

template <class ContainerAllocator> struct IsMessage<::sensor_msgs::LiDARFrame_<ContainerAllocator> const> : TrueType {};

template <class ContainerAllocator> struct HasHeader<::sensor_msgs::LiDARFrame_<ContainerAllocator>> : TrueType {};

template <class ContainerAllocator> struct HasHeader<::sensor_msgs::LiDARFrame_<ContainerAllocator> const> : TrueType {};

template <class ContainerAllocator> struct MD5Sum<::sensor_msgs::LiDARFrame_<ContainerAllocator>> {
    static const char *value() {
        return "5bb7096e1239fb4a5bebe83d873b71ad";
    }

    static const char *value(const ::sensor_msgs::LiDARFrame_<ContainerAllocator> &) {
        return value();
    }
    static const uint64_t static_value1 = 0x5bb7096e1239fb4aULL;
    static const uint64_t static_value2 = 0x5bebe83d873b71adULL;
};

template <class ContainerAllocator> struct DataType<::sensor_msgs::LiDARFrame_<ContainerAllocator>> {
    static const char *value() {
        return "sensor_msgs/LiDARFrame";
    }

    static const char *value(const ::sensor_msgs::LiDARFrame_<ContainerAllocator> &) {
        return value();
    }
};

template <class ContainerAllocator> struct Definition<::sensor_msgs::LiDARFrame_<ContainerAllocator>> {
    static const char *value() {
        return "# This message contains an uncompressed lidar frame\n\
#\n\
\n\
Header header        # Header timestamp should be acquisition time of frame\n\
\n\
string format # format of the frame data\n\
uint64 timestamp_usec # frame timestamp_usec, that is timestamp when frame captured\n\
uint64 timestamp_systemusec # frame timestamp_systemusec, that is timestamp when image captured\n\
uint64 timestamp_globalusec # frame timestamp_globalusec, that is timestamp when image captured\n\
\n\
uint32 metadatasize   # metadatasize\n\
uint8[] data          # actual matrix data, size is (step * rows)\n\
uint64 number         \n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
";
    }

    static const char *value(const ::sensor_msgs::LiDARFrame_<ContainerAllocator> &) {
        return value();
    }
};

}  // namespace message_traits
}  // namespace orbbecRosbag

namespace orbbecRosbag {
namespace serialization {

template <class ContainerAllocator> struct Serializer<::sensor_msgs::LiDARFrame_<ContainerAllocator>> {
    template <typename Stream, typename T> inline static void allInOne(Stream &stream, T m) {
        stream.next(m.header);
        stream.next(m.metadatasize);
        stream.next(m.data);
        stream.next(m.format);
        stream.next(m.number);
        stream.next(m.timestamp_usec);
        stream.next(m.timestamp_systemusec);
        stream.next(m.timestamp_globalusec);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
};  // struct LiDARFrame_

}  // namespace serialization
}  // namespace orbbecRosbag

namespace orbbecRosbag {
namespace message_operations {

template <class ContainerAllocator> struct Printer<::sensor_msgs::LiDARFrame_<ContainerAllocator>> {
    template <typename Stream> static void stream(Stream &s, const std::string &indent, const ::sensor_msgs::LiDARFrame_<ContainerAllocator> &v) {
        s << indent << "header: ";
        s << std::endl;
        Printer<::std_msgs::Header_<ContainerAllocator>>::stream(s, indent + "  ", v.header);
        s << indent << "format: ";
        Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other>>::stream(s, indent + "  ", v.format);
        s << indent << "timestamp_usec: ";
        Printer<uint64_t>::stream(s, indent + "  ", v.timestamp_usec);
        s << indent << "timestamp_systemusec: ";
        Printer<uint64_t>::stream(s, indent + "  ", v.timestamp_systemusec);
        s << indent << "timestamp_globalusec: ";
        Printer<uint64_t>::stream(s, indent + "  ", v.timestamp_globalusec);
        s << indent << "metadatasize: ";
        Printer<uint32_t>::stream(s, indent + "  ", v.metadatasize);
        s << indent << "data[]" << std::endl;
        for(size_t i = 0; i < v.data.size(); ++i) {
            s << indent << "  data[" << i << "]: ";
            Printer<uint8_t>::stream(s, indent + "  ", v.data[i]);
        }
        s << indent << "number: ";
        Printer<uint32_t>::stream(s, indent + "  ", v.number);
    }
};

}  // namespace message_operations
}  // namespace orbbecRosbag

#endif  // SENSOR_MSGS_MESSAGE_LIDAR_FRAME_H
